    ; EXPEVA
    ;
    ;include EXPEVA/Precedence.mips
    ;include AddSub16.mips
    ;include Mult16.mips
    ;include Div16.mips
    ;include Comp16.mips
    ;
    ; MEM[0x09] = n_sp (point to the next)
    ; MEM[0x0a] = o_sp (point to the next)
    ; MEM[0x0b] = is_number
    ; MEM[0x0c] = is_after_OK
    ;
    ; MEM[0x4f .. 0x10] : numbers (32)
    ; MEM[0x7f .. 0x50] : operators (48)
    ;
    ; Method Implementation
    ; =====================
    ; Init_EXPEVA: Stack initialize
Init_EXPEVA:
    PUSH BP
    ANDI R1, R1, 0x00
    ADDI R0, R1, 0x12
    SW   R0, R1, 0x09
    SW   R1, R1, 0x10
    SW   R1, R1, 0x11
    ADDI R0, R1, 0x50
    SW   R0, R1, 0x0a
    SW   R1, R1, 0x0b
    ADDI R0, R1, 0x01
    SW   R0, R1, 0x0c
    RET
    ; Top_EXPEVA: Get top number
    ; arg[1..0] result
Top_EXPEVA:
    PUSH BP
    ANDI R1, R1, 0x00
    LW   R3, R1, 0x09
    LW   R2, R1, 0xfe
    LW   R0, R3, -2
    SW   R0, R2, 0x03
    LW   R0, R3, -1
    SW   R0, R2, 0x04
    RET
    ; Digit_EXPEVA: Push one digit or create number
    ; arg[0]: digit
Digit_EXPEVA:
    PUSH BP
    ANDI R1, R1, 0x00
    LW   R0, R1, 0x0c
    BEQ  R0, R1, after_clear_Digit_EXPEVA
    CALL free_number
    SW   R1, R1, 0x0b
    SW   R1, R1, 0x0c
after_clear_Digit_EXPEVA:
    LW   R0, R1, 0x0b
    BEQ  R0, R1, create_Digit_EXPEVA
    ADDI R0, R1, 0
    PUSH R0
    ADDI R0, R1, 10
    PUSH R0
    LW   R3, R1, 0xff
    LW   R0, R1, 0x09
    ADDI R0, R0, 0xfe
    PUSH R3
    PUSH R0
    CALL Mult16ps
    ANDI R1, R1, 0x00
    LW   R3, R1, 0xff
    ADDI R3, R3, 4
    SW   R3, R1, 0xff
    ADDI R0, R1, 0
    PUSH R0
    LW   R2, R1, 0xfe
    LW   R0, R2, 0x03
    PUSH R0
    LW   R3, R1, 0xff
    LW   R0, R1, 0x09
    ADDI R0, R0, 0xfe
    PUSH R0
    PUSH R3
    CALL Add16p
    JMP  done_Digit_EXPEVA
create_Digit_EXPEVA:
    CALL allocate_number
    ANDI R1, R1, 0x00
    LW   R2, R1, 0xfe
    LW   R0, R2, 0x03
    LW   R2, R1, 0x09
    SW   R1, R2, -1
    SW   R0, R2, -2
    ADDI R0, R1, 0x01
    SW   R0, R1, 0x0b
done_Digit_EXPEVA:
    RET
    ; Operator_EXPEVA: Push one operator
    ; may use binary op for unary op
Operator_EXPEVA:
    PUSH BP
    ANDI R1, R1, 0x00
    ; sp -= 1
    LW   R3, R1, 0xff
    ADDI R3, R3, 0xff
    SW   R3, R1, 0xff
    ; *sp = arg[0]
    LW   R2, R1, 0xfe
    LW   R0, R2, 0x03
    SW   R0, R3, 0x00
    SW   R1, R1, 0x0c
    LW   R0, R1, 0x0b
    BNE  R0, R1, parse_Operator_EXPEVA
    LW   R0, R3, 0x00
    ADDI R2, R1, 0x02   ; Plus
    BNE  R0, R2, not_plus_Operator_EXPEVA
    ADDI R0, R1, 0x00   ; Unary Plus
    SW   R0, R3, 0x00
    JMP  push_op_Operator_EXPEVA
not_plus_Operator_EXPEVA:
    ADDI R2, R1, 0x03   ; Minus
    BNE  R0, R2, not_minus_Operator_EXPEVA
    ADDI R0, R1, 0x01   ; Unary Minus
    SW   R0, R3, 0x00
    JMP  push_op_Operator_EXPEVA
not_minus_Operator_EXPEVA:
    ADDI R2, R1, 0x00   ; Unary Plus
    BEQ  R0, R2, push_op_Operator_EXPEVA
    ADDI R2, R1, 0x01   ; Unary Minus
    BEQ  R0, R2, push_op_Operator_EXPEVA
    ADDI R2, R1, 0x07   ; Bit-wise Not
    BEQ  R0, R2, push_op_Operator_EXPEVA
    ADDI R2, R1, 0x0b   ; Left Parenthesis
    BEQ  R0, R2, push_op_Operator_EXPEVA
    RET
parse_Operator_EXPEVA:
    ADDI R2, R1, 0x0b   ; Left Parenthesis
    BEQ  R0, R2, push_op_Operator_EXPEVA
flush_Operator_EXPEVA:
    ANDI R1, R1, 0x00
    LW   R3, R1, 0xff
    LW   R0, R1, 0x0a
    ADDI R2, R1, 0x50
    BNE  R0, R2, compare_Operator_EXPEVA
    LW   R0, R3, 0x00
    ADDI R2, R1, 0x0c   ; Right Parenthesis
    BEQ  R0, R2, fail_Operator_EXPEVA
    ADDI R2, R1, 0x0f   ; OK
    BNE  R0, R2, push_op_Operator_EXPEVA
    ANDI R1, R1, 0x00
    ADDI R0, R1, 0x01
    SW   R0, R1, 0x0c
    JMP  done_Operator_EXPEVA
compare_Operator_EXPEVA:
    LW   R0, R3, 0x00
    ADDI R2, R1, 0x0c   ; Right Parenthesis
    BNE  R0, R2, not_rp_at_compare_Operator_EXPEVA
    ; R0 = *(o_sp-1)
    LW   R0, R1, 0x0a
    LW   R0, R0, 0xff
    ADDI R2, R1, 0x0b   ; Left Parenthesis
    BNE  R0, R2, evaluate_Operator_EXPEVA
    CALL pop_operator
    JMP  done_Operator_EXPEVA
not_rp_at_compare_Operator_EXPEVA:
    ; R0 = *(o_sp-1)
    LW   R0, R1, 0x0a
    LW   R0, R0, 0xff
    PUSH R0
    CALL Precedence_EXPEVA
    POP  R2
    BEQ  R0, R1, push_op_Operator_EXPEVA
evaluate_Operator_EXPEVA:
    ; R0 = *(o_sp-1)
    LW   R0, R1, 0x0a
    LW   R0, R0, 0xff
    PUSH R0
    CALL evaluate_EXPEVA
    POP  R0
    CALL pop_operator
    JMP  flush_Operator_EXPEVA
push_op_Operator_EXPEVA:
    CALL push_operator
    ANDI R1, R1, 0x00
    SW   R1, R1, 0x0b
    JMP  done_Operator_EXPEVA
fail_Operator_EXPEVA:
    ANDI R0, R0, 0x00
    ADDI R0, R0, 0x01
done_Operator_EXPEVA:
    RET
    ; Back_EXPEVA: Remove last digit
    ; return: 0 is succeed
Back_EXPEVA:
    PUSH BP
    ANDI R1, R1, 0x00
    LW   R0, R1, 0x0b
    BEQ  R0, R1, fail_Back_EXPEVA
    ADDI R0, R1, 0
    PUSH R0
    ADDI R0, R1, 10
    PUSH R0
    LW   R3, R1, 0xff
    LW   R0, R1, 0x09
    ADDI R0, R0, 0xfe
    PUSH R0
    PUSH R3
    CALL Div16p
    ANDI R0, R0, 0x00
    RET
fail_Back_EXPEVA:
    ANDI R0, R0, 0x00
    ADDI R0, R0, 0x01
    RET
evaluate_EXPEVA:
    PUSH BP
    ANDI R1, R1, 0x00
    LW   R2, R1, 0xfe
    LW   R0, R2, 0x03
    PUSH R0
    ADDPC
    JMP  eval_UnaryPlus
    JMP  eval_UnaryMinus
    JMP  eval_Plus
    JMP  eval_Minus
    JMP  eval_Multiply
    JMP  eval_Divide
    JMP  eval_Reminder
    JMP  eval_BitwiseNot
    JMP  eval_BitwiseAnd
    JMP  eval_BitwiseOr
    JMP  eval_BitwiseXor
    JMP  eval_LeftParenthesis
    JMP  eval_RightParenthesis
    JMP  eval_LessThan
    JMP  eval_EqualTo
    JMP  eval_OK
eval_UnaryPlus:
    JMP  eval_done
eval_UnaryMinus:
    ANDI R1, R1, 0x00
    LW   R2, R1, 0x09
    LW   R0, R2, -2
    SUB  R0, R1, R0
    SW   R0, R2, -2
    LW   R0, R2, -1
    SUBC R0, R1, R0
    SW   R0, R2, -1
    JMP  eval_done
eval_BitwiseNot:
    ANDI R1, R1, 0x00
    LW   R2, R1, 0x09
    ORI  R1, R1, 0xff
    LW   R0, R2, -2
    SUB  R0, R1, R0
    SW   R0, R2, -2
    LW   R0, R2, -1
    SUB  R0, R1, R0
    SW   R0, R2, -1
    JMP  eval_done
eval_Plus:
    ANDI R1, R1, 0x00
    LW   R2, R1, 0x09
    ADDI R0, R2, -4
    PUSH R0
    ADDI R0, R2, -2
    PUSH R0
    CALL Add16p
    CALL free_number
    JMP  eval_done
eval_Minus:
    ANDI R1, R1, 0x00
    LW   R2, R1, 0x09
    ADDI R0, R2, -4
    PUSH R0
    ADDI R0, R2, -2
    PUSH R0
    CALL Sub16p
    CALL free_number
    JMP  eval_done
eval_Multiply:
    ANDI R1, R1, 0x00
    LW   R2, R1, 0x09
    ADDI R0, R2, -2
    PUSH R0
    ADDI R0, R2, -4
    PUSH R0
    CALL Mult16ps
    CALL free_number
    JMP  eval_done
eval_Divide:
    ANDI R1, R1, 0x00
    LW   R2, R1, 0x09
    ADDI R0, R2, -4
    PUSH R0
    ADDI R0, R2, -2
    PUSH R0
    CALL Div16ps
    ANDI R1, R1, 0x00
    LW   R2, R1, 0x09
    LW   R0, R2, -2
    SW   R0, R2, -4
    LW   R0, R2, -1
    SW   R0, R2, -3
    CALL free_number
    JMP  eval_done
eval_Reminder:
    ANDI R1, R1, 0x00
    LW   R2, R1, 0x09
    ADDI R0, R2, -4
    PUSH R0
    ADDI R0, R2, -2
    PUSH R0
    CALL Div16ps
    CALL free_number
    JMP  eval_done
eval_BitwiseAnd:
    ANDI R1, R1, 0x00
    LW   R2, R1, 0x09
    LW   R0, R2, -2
    LW   R3, R2, -4
    AND  R0, R0, R3
    SW   R0, R2, -4
    LW   R0, R2, -1
    LW   R3, R2, -3
    AND  R0, R0, R3
    SW   R0, R2, -3
    CALL free_number
    JMP  eval_done
eval_BitwiseOr:
    ANDI R1, R1, 0x00
    LW   R2, R1, 0x09
    LW   R0, R2, -2
    LW   R3, R2, -4
    OR   R0, R0, R3
    SW   R0, R2, -4
    LW   R0, R2, -1
    LW   R3, R2, -3
    OR   R0, R0, R3
    SW   R0, R2, -3
    CALL free_number
    JMP  eval_done
eval_BitwiseXor:
    ANDI R1, R1, 0x00
    LW   R2, R1, 0x09
    LW   R0, R2, -2
    LW   R3, R2, -4
    AND  R1, R0, R3
    OR   R0, R0, R3
    ORI  R3, R3, 0xff
    SUB  R3, R3, R1
    AND  R0, R0, R3
    SW   R0, R2, -4
    LW   R0, R2, -1
    LW   R3, R2, -3
    AND  R0, R0, R3
    OR   R0, R0, R3
    ORI  R3, R3, 0xff
    SUB  R3, R3, R1
    AND  R0, R0, R3
    SW   R0, R2, -3
    CALL free_number
    JMP  eval_done
eval_LessThan:
    ANDI R1, R1, 0x00
    LW   R2, R1, 0x09
    ADDI R0, R2, -2
    PUSH R0
    ADDI R0, R2, -4
    PUSH R0
    CALL Comp16p
    ANDI R1, R1, 0x00
    ADDI R1, R1, 0x01
    BEQ  R0, R1, eval_LTEQ_yes
    JMP  eval_LTEQ_no
eval_EqualTo:
    ANDI R1, R1, 0x00
    LW   R2, R1, 0x09
    ADDI R0, R2, -2
    PUSH R0
    ADDI R0, R2, -4
    PUSH R0
    CALL Comp16p
    ANDI R1, R1, 0x00
    BEQ  R0, R1, eval_LTEQ_yes
    JMP  eval_LTEQ_no
eval_LTEQ_yes:
    ANDI R1, R1, 0x00
    LW   R2, R1, 0x09
    ADDI R0, R1, 0x01
    SW   R0, R2, -4
    SW   R1, R2, -3
    CALL free_number
    JMP  eval_done
eval_LTEQ_no:
    ANDI R1, R1, 0x00
    LW   R2, R1, 0x09
    SW   R1, R2, -4
    SW   R1, R2, -3
    CALL free_number
    JMP  eval_done
eval_LeftParenthesis:
eval_RightParenthesis:
eval_OK:
eval_done:
    RET
allocate_number:
    PUSH BP
    ANDI R1, R1, 0x00
    ; n_sp += 2
    LW   R3, R1, 0x09
    ADDI R3, R3, 0x02
    SW   R3, R1, 0x09
    RET
free_number:
    PUSH BP
    ANDI R1, R1, 0x00
    ; n_sp -= 2
    LW   R3, R1, 0x09
    ADDI R3, R3, 0xfe
    SW   R3, R1, 0x09
    RET
push_operator:
    PUSH BP
    ANDI R1, R1, 0x00
    LW   R2, R1, 0xfe
    LW   R0, R2, 0x03
    LW   R3, R1, 0x0a
    ; *o_sp = arg[0]
    SW   R0, R3, 0x00
    ; o_sp += 1
    ADDI R3, R3, 0x01
    SW   R3, R1, 0x0a
    RET
pop_operator:
    PUSH BP
    ANDI R1, R1, 0x00
    ; o_sp -= 1
    LW   R3, R1, 0x0a
    ADDI R3, R3, 0xff
    SW   R3, R1, 0x0a
    LW   R0, R3, 0x00
    RET
